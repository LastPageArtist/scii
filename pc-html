<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Painting Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }

        #canvasContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #canvas {
            display: inline-block;
            background: #0d1117;
            border: 1px solid #30363d;
            padding: 10px;
            line-height: 1;
            cursor: crosshair;
            user-select: none;
            position: relative;
        }

        #canvas.select-mode {
            cursor: default;
        }

        #canvas.eraser-mode {
            cursor: pointer;
        }

        .row {
            white-space: pre;
        }

        .cell {
            display: inline-block;
            text-align: center;
        }

        .cell:hover {
            background: #1f6feb;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #58a6ff;
            background: rgba(88, 166, 255, 0.1);
            pointer-events: none;
        }

        .panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            width: 320px;
            z-index: 1000;
        }

        .panel-header {
            padding: 8px 10px;
            border-top: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
        }

        .panel-header:hover {
            background: #1c2128;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .current-char {
            display: inline-block;
            background: #0d1117;
            border: 1px solid #30363d;
            padding: 3px 6px;
            min-width: 24px;
            text-align: center;
        }

        .toggle-icon {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .toggle-icon.collapsed {
            transform: rotate(180deg);
        }

        .panel-content {
            padding: 10px;
            max-height: 65vh;
            overflow-y: auto;
            border-bottom: 1px solid #30363d;
        }

        .panel-content.collapsed {
            display: none;
        }

        .control-group {
            margin-bottom: 10px;
        }

        .control-group label {
            display: block;
            font-size: 10px;
            margin-bottom: 4px;
            color: #8b949e;
            text-transform: uppercase;
        }

        .size-inputs {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .size-inputs input {
            width: 55px;
            font-size: 13px;
            padding: 5px 6px;
        }

        input, button {
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 5px 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-radius: 3px;
        }

        button {
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #21262d;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            min-width: 45px;
        }

        .keyboard {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .kbd-row {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
        }

        .key {
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 4px;
            min-width: 22px;
            text-align: center;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            border-radius: 2px;
            transition: all 0.1s;
        }

        .key:hover {
            background: #21262d;
            border-color: #58a6ff;
        }

        .key.active {
            background: #1f6feb;
            border-color: #1f6feb;
        }

        .tool-mode {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .tool-btn {
            flex: 1;
            padding: 6px;
            font-size: 10px;
            min-width: 50px;
        }

        .tool-btn.active {
            background: #1f6feb;
            border-color: #1f6feb;
        }

        #customCharInput {
            width: 100%;
            padding: 5px;
            font-size: 12px;
        }

        #savedProjectsList {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #30363d;
            border-radius: 3px;
            padding: 5px;
            background: #0d1117;
        }

        .saved-item {
            padding: 5px;
            cursor: pointer;
            border-radius: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
            font-size: 10px;
        }

        .saved-item:hover {
            background: #21262d;
        }

        .saved-item-name {
            flex: 1;
        }

        .saved-item-delete {
            color: #f85149;
            font-size: 9px;
            padding: 2px 5px;
        }

        .saved-item-delete:hover {
            background: #f85149;
            color: #fff;
        }

        #projectName {
            width: 100%;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <div id="canvas"></div>
    </div>

    <div class="panel">
        <div class="panel-content" id="panelContent">
            <div class="tool-mode">
                <button class="tool-btn active" onclick="setTool('draw')" id="drawBtn">DRAW</button>
                <button class="tool-btn" onclick="setTool('eraser')" id="eraserBtn">ERASE</button>
         
                <button class="tool-btn" onclick="setTool('fill')" id="fillBtn">FILL</button>
                <button class="tool-btn" onclick="setTool('select')" id="selectBtn">SELECT</button>
            </div>

            <div class="control-group">
                <label>Canvas Size</label>
                <div class="size-inputs">
            
                 <input type="number" id="width" value="120" min="10" max="200">
                    <span>×</span>
                    <input type="number" id="height" value="20" min="10" max="80">
                    <button onclick="resizeCanvas()">Apply</button>
                </div>
     
               </div>

            <div class="control-group">
                <label>Font Size</label>
                <div class="size-inputs">
                    <input type="number" id="fontSize" value="14" min="8" max="32" step="1">
                    
                     <span>px</span>
                    <button onclick="updateFontSize()">Apply</button>
                </div>
            </div>

            <div class="control-group">
                <label>Actions</label>
                <div class="button-group">
     
                                 <button onclick="undo()" id="undoBtn" disabled>Undo</button>
                    <button onclick="redo()" id="redoBtn" disabled>Redo</button>
                    <button onclick="clearCanvas()">Clear</button>
                    <button onclick="exportText()">Copy</button>
                 
                     <button onclick="exportPNG()">PNG</button>
                </div>
            </div>

            <div class="control-group">
                <label>Save/Load Project</label>
                <input type="text" id="projectName" placeholder="Project name...">
                <div class="button-group">
 
                                        <button onclick="saveProject()">Save</button>
                    <button onclick="loadLastProject()">Load Last</button>
                </div>
                <div class="button-group" style="margin-top: 4px;">
                    <button onclick="downloadProject()">Download</button>
  
                                       <button onclick="document.getElementById('fileInput').click()">Import</button>
                </div>
                <input type="file" id="fileInput" accept=".json" style="display: none;"
                 onchange="importProject(event)">
                <div id="savedProjectsList" style="margin-top: 5px;"></div>
            </div>

            <div class="control-group" id="selectionTools" style="display: none;">
                <label>Selection</label>
                <div class="button-group">
                    
                      <button onclick="duplicateSelection()">Duplicate</button>
                    <button onclick="clearSelection()">Delete</button>
                    <button onclick="cancelSelection()">Cancel</button>
                </div>
            </div>

            <div class="control-group">
                
                  <label>Custom Character</label>
                <input type="text" id="customCharInput" maxlength="1" placeholder="Enter any character">
            </div>

            <div class="control-group">
                <label>Characters</label>
                <div class="keyboard" id="keyboard"></div>
            </div>
      
          </div>

        <div class="panel-header" onclick="togglePanel()">
            <div class="panel-title">
                <span>TOOLS</span>
                <span class="current-char" id="charPreview">#</span>
            </div>
            <span class="toggle-icon" id="toggleIcon">▼</span>
        </div>
    </div>

   
     <script>
        let width = 120;
        let height = 20;
        let fontSize = 14;
        let charWidth = 8.4;
        let charHeight = 16;
        let currentChar = '#';
        let currentTool = 'draw';
        let isDrawing = false;
        let grid = [];

        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let selectionBox = null;
        let selectedData = null;
        let isDraggingSelection = false;
        let dragOffset = { x: 0, y: 0 };
        let dragStartPos = null;
        let gridBeforeDrag = null;
        let history = [];
        let historyStep = -1;
        const MAX_HISTORY = 50;
        const blocks = ['█', '▓', '▒', '░', '▀', '▄', '▌', '▐', '■', '□', '▪', '▫', '◘', '◙'];
        const lines = ['─', '│', '┌', '┐', '└', '┘', '├', '┤', '┬', '┴', '┼', '═', '║', '╔', '╗', '╚', '╝', '╠', '╣', '╦', '╩', '╬'];
        const basic = ['/', '\\', '|', '-', '+', '*', '#', '@', '$', '%', '&', '!', '?', '~', '^', '=', '_', '<', '>', '.', ',', ':', ';'];
        const brackets = ['(', ')', '[', ']', '{', '}'];
        const quotes = ['"', "'", '`'];
        const math = ['÷', '×', '±', '≈', '≠', '≤', '≥', '∞', '∑', '√', '∫'];
        const arrows = ['←', '→', '↑', '↓', '↔', '↕', '⇐', '⇒'];
        const shapes = ['○', '●', '◯', '☐', '☑', '☒', '♠', '♣', '♥', '♦', '★', '☆'];
        const greek = ['α', 'β', 'γ', 'δ', 'ε', 'π', 'σ', 'ω', 'Σ', 'Π', 'Ω'];
    
        const misc = ['©', '®', '™', '§', '¶', '†', '°', '¢', '£', '¥', '€'];
        const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const letters = 'QWERTYUIOPASDFGHJKLZXCVBNM'.split('');
        const lowercase = 'qwertyuiopasdfghjklzxcvbnm'.split('');

        function calculateCharDimensions() {
            // UNIVERSAL FIX: Round both charWidth and charHeight to the nearest integer 
            // to prevent sub-pixel rendering errors which cause visible horizontal or vertical lines/gaps.
            charWidth = Math.round(fontSize * 0.6);
            charHeight = Math.round(fontSize * 1.15); 
        }

        function initKeyboard() {
            const kbd = document.getElementById('keyboard');
            addKeyRow(kbd, blocks);
            addKeyRow(kbd, lines.slice(0, 15));
            addKeyRow(kbd, basic);
            addKeyRow(kbd, [...brackets, ...quotes]);
            addKeyRow(kbd, math);
            addKeyRow(kbd, arrows);
            addKeyRow(kbd, shapes);
            addKeyRow(kbd, greek);
            addKeyRow(kbd, misc);
            addKeyRow(kbd, numbers);
            addKeyRow(kbd, letters.slice(0, 13));
            addKeyRow(kbd, letters.slice(13));
            addKeyRow(kbd, lowercase.slice(0, 13));
            addKeyRow(kbd, lowercase.slice(13));
            addKeyRow(kbd, [' ']);
        }

        function addKeyRow(parent, keys) {
            const row = document.createElement('div');
            row.className = 'kbd-row';
            keys.forEach(key => {
                const btn = document.createElement('div');
                btn.className = 'key';
                btn.textContent = key === ' ' ? '⎵' : key;
                btn.onclick = () => selectChar(key);
             
                if (key === currentChar) btn.classList.add('active');
                row.appendChild(btn);
            });
            parent.appendChild(row);
        }

        document.getElementById('customCharInput').addEventListener('input', (e) => {
            const char = e.target.value;
            if (char) {
                selectChar(char);
                e.target.value = '';
            }
        });
        function selectChar(char) {
            currentChar = char;
            document.querySelectorAll('.key').forEach(b => b.classList.remove('active'));
            if (event && event.target) event.target.classList.add('active');
            const preview = document.getElementById('charPreview');
            preview.textContent = char === ' ' ? '⎵' : char;
            preview.style.fontSize = fontSize + 'px';
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(tool + 'Btn').classList.add('active');

            const canvas = document.getElementById('canvas');
            canvas.classList.remove('select-mode', 'eraser-mode');
            if (tool === 'select') {
                canvas.classList.add('select-mode');
            } else if (tool === 'eraser') {
                canvas.classList.add('eraser-mode');
                cancelSelection();
            } else {
                cancelSelection();
            }
        }

        function togglePanel() {
            const content = document.getElementById('panelContent');
            const icon = document.getElementById('toggleIcon');
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        function updateFontSize() {
            fontSize = parseInt(document.getElementById('fontSize').value);
            calculateCharDimensions();

            const canvas = document.getElementById('canvas');
            canvas.style.fontSize = fontSize + 'px';

            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.width = charWidth + 'px';
                cell.style.height = charHeight + 'px';
            });
            const rows = document.querySelectorAll('.row');
            rows.forEach(row => {
                row.style.height = charHeight + 'px';
            });
            document.getElementById('charPreview').style.fontSize = fontSize + 'px';
        }

        function saveState() {
            history = history.slice(0, historyStep + 1);
            const gridCopy = grid.map(row => [...row]);
            history.push(gridCopy);

            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyStep++;
            }

            updateUndoRedoButtons();
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(history[historyStep]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                restoreState(history[historyStep]);
                updateUndoRedoButtons();
            }
        }

        function restoreState(state) {
            grid = state.map(row => [...row]);
            renderGrid();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyStep <= 0;
            document.getElementById('redoBtn').disabled = historyStep >= history.length - 1;
        }

        function initCanvas() {
            calculateCharDimensions();
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '';
            canvas.style.fontSize = fontSize + 'px';
            grid = [];
            for (let y = 0; y < height; y++) {
                const row = document.createElement('div');
                row.className = 'row';
                row.style.height = charHeight + 'px';
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    const cell = document.createElement('span');
                    cell.className = 'cell';
                    cell.style.width = charWidth + 'px';
                    cell.style.height = charHeight + 'px';
                    cell.textContent = ' ';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    cell.addEventListener('mousedown', (e) => handleMouseDown(e, x, y));
                    cell.addEventListener('mouseenter', () => handleMouseEnter(x, y));

                    row.appendChild(cell);
                    grid[y][x] = ' ';
                }

                canvas.appendChild(row);
            }

            document.addEventListener('mouseup', handleMouseUp);

            saveState();
        }

        function handleMouseDown(e, x, y) {
            e.preventDefault();
            if (currentTool === 'draw') {
                isDrawing = true;
                drawCell(x, y);
            } else if (currentTool === 'eraser') {
                isDrawing = true;
                eraseCell(x, y);
            } else if (currentTool === 'fill') {
                floodFill(x, y);
            } else if (currentTool === 'select') {
                if (selectionBox && isInsideSelection(x, y)) {
                    isDraggingSelection = true;
                    dragStartPos = { x, y };
                    dragOffset = {
                        x: x - Math.min(selectionStart.x, selectionEnd.x),
                        y: y - Math.min(selectionStart.y, selectionEnd.y)
                    };
                    gridBeforeDrag = grid.map(row => [...row]);
                    
                    const minX = Math.min(selectionStart.x, selectionEnd.x);
                    const maxX = Math.max(selectionStart.x, selectionEnd.x);
                    const minY = Math.min(selectionStart.y, selectionEnd.y);
                    const maxY = Math.max(selectionStart.y, selectionEnd.y);
                    
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            gridBeforeDrag[y][x] = ' ';
                        }
                    }
                } else {
                    isSelecting = true;
                    selectionStart = { x, y };
                    selectionEnd = { x, y };
                    createSelectionBox();
                }
            }
        }

        function handleMouseEnter(x, y) {
            if (isDrawing && currentTool === 'draw') {
                drawCell(x, y);
            } else if (isDrawing && currentTool === 'eraser') {
                eraseCell(x, y);
            } else if (isSelecting) {
                selectionEnd = { x, y };
                updateSelectionBox();
            } else if (isDraggingSelection) {
                moveSelection(x, y);
            }
        }

        function handleMouseUp() {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            } else if (isSelecting) {
                isSelecting = false;
                finalizeSelection();
            } else if (isDraggingSelection) {
                isDraggingSelection = false;
                dragStartPos = null;
                gridBeforeDrag = null;
                saveState();
            }
        }

        function isInsideSelection(x, y) {
            if (!selectionStart || !selectionEnd) return false;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            return x >= minX && x <= maxX && y >= minY && y <= maxY;
        }

        function createSelectionBox() {
            if (selectionBox) selectionBox.remove();
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            document.getElementById('canvas').appendChild(selectionBox);
            updateSelectionBox();
        }

        function updateSelectionBox() {
            if (!selectionBox || !selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            selectionBox.style.left = (minX * charWidth) + 'px';
            selectionBox.style.top = (minY * charHeight) + 'px';
            selectionBox.style.width = ((maxX - minX + 1) * charWidth) + 'px';
            selectionBox.style.height = ((maxY - minY + 1) * charHeight) + 'px';
        }

        function finalizeSelection() {
            if (!selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            selectedData = [];
            for (let y = minY; y <= maxY; y++) {
                const row = [];
                for (let x = minX; x <= maxX; x++) {
                    row.push(grid[y][x]);
                }
                selectedData.push(row);
            }

            document.getElementById('selectionTools').style.display = 'block';
        }

        function moveSelection(x, y) {
            if (!selectedData || !dragStartPos || !gridBeforeDrag) return;
            const newX = x - dragOffset.x;
            const newY = y - dragOffset.y;

            const oldMinX = Math.min(selectionStart.x, selectionEnd.x);
            const oldMaxX = Math.max(selectionStart.x, selectionEnd.x);
            const oldMinY = Math.min(selectionStart.y, selectionEnd.y);
            const oldMaxY = Math.max(selectionStart.y, selectionEnd.y);
            const w = oldMaxX - oldMinX;
            const h = oldMaxY - oldMinY;
            const clampedX = Math.max(0, Math.min(width - w - 1, newX));
            const clampedY = Math.max(0, Math.min(height - h - 1, newY));
            grid = gridBeforeDrag.map(row => [...row]);

            for (let sy = 0; sy < selectedData.length; sy++) {
                for (let sx = 0; sx < selectedData[0].length; sx++) {
                    const targetY = clampedY + sy;
                    const targetX = clampedX + sx;
                    const char = selectedData[sy][sx];
                    if (char !== ' ' && targetY >= 0 && targetY < height && targetX >= 0 && targetX < width) {
                        grid[targetY][targetX] = char;
                    }
                }
            }

            selectionStart = { x: clampedX, y: clampedY };
            selectionEnd = { x: clampedX + w, y: clampedY + h };

            renderGrid();
            updateSelectionBox();
        }

        function duplicateSelection() {
            if (!selectedData || !selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            const w = maxX - minX + 1;

            const newX = Math.min(minX + w + 2, width - w);
            for (let sy = 0; sy < selectedData.length; sy++) {
                for (let sx = 0; sx < selectedData[0].length; sx++) {
                    const targetY = minY + sy;
                    const targetX = newX + sx;
                    const char = selectedData[sy][sx];
                    if (char !== ' ' && targetY >= 0 && targetY < height && targetX >= 0 && targetX < width) {
                        grid[targetY][targetX] = char;
                    }
                }
            }

            renderGrid();
            saveState();
        }

        function clearSelection() {
            if (!selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    grid[y][x] = ' ';
                }
            }

            renderGrid();
            saveState();
            cancelSelection();
        }

        function cancelSelection() {
            if (selectionBox) {
                selectionBox.remove();
                selectionBox = null;
            }
            selectionStart = null;
            selectionEnd = null;
            selectedData = null;
            dragStartPos = null;
            document.getElementById('selectionTools').style.display = 'none';
        }

        function drawCell(x, y) {
            const cell = document.querySelector('[data-x="' + x + '"][data-y="' + y + '"]');
            cell.textContent = currentChar;
            grid[y][x] = currentChar;
        }

        function eraseCell(x, y) {
            const cell = document.querySelector('[data-x="' + x + '"][data-y="' + y + '"]');
            cell.textContent = ' ';
            grid[y][x] = ' ';
        }

        function renderGrid() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = document.querySelector('[data-x="' + x + '"][data-y="' + y + '"]');
                    if (cell) {
                        cell.textContent = grid[y][x];
                    }
                }
            }
        }

        function floodFill(startX, startY) {
            const targetChar = grid[startY][startX];
            if (targetChar === currentChar) return;

            const stack = [[startX, startY]];
            const filled = new Set();
            while (stack.length > 0) {
                const pos = stack.pop();
                const x = pos[0];
                const y = pos[1];
                const key = x + ',' + y;
                if (x < 0 || x >= width || y < 0 || y >= height || filled.has(key)) {
                    continue;
                }

                if (grid[y][x] !== targetChar) {
                    continue;
                }

                grid[y][x] = currentChar;
                filled.add(key);
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }

            renderGrid();
            saveState();
        }

        function clearCanvas() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    grid[y][x] = ' ';
                }
            }
            renderGrid();
            saveState();
        }

        function resizeCanvas() {
            width = parseInt(document.getElementById('width').value);
            height = parseInt(document.getElementById('height').value);
            initCanvas();
        }

        function exportText() {
            const text = grid.map(row => row.join('')).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard');
            });
        }

        function exportPNG() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = width * charWidth;
            canvas.height = height * charHeight;

            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = fontSize + 'px "Courier New", monospace';
            ctx.fillStyle = '#c9d1d9';
            ctx.textBaseline = 'top';
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const char = grid[y][x];
                    if (char !== ' ') {
                        ctx.fillText(char, x * charWidth, y * charHeight);
                    }
                }
            }

            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
  
                a.download = 'ascii-art.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // Save/Load functionality using localStorage
        function saveProject() {
            const projectName = document.getElementById('projectName').value.trim() ||
            'Untitled';
            
            const projectData = {
                name: projectName,
                width: width,
                height: height,
                fontSize: fontSize,
                grid: grid,
           
                timestamp: Date.now()
            };
            try {
                localStorage.setItem('ascii-project-' + projectName, JSON.stringify(projectData));
                alert('Project saved: ' + projectName);
                loadProjectsList();
            } catch (error) {
                console.error('Save error:', error);
                alert('Failed to save project');
            }
        }

        function loadProject(projectName) {
            try {
                const projectJSON = localStorage.getItem('ascii-project-' + projectName);
                if (projectJSON) {
                    const projectData = JSON.parse(projectJSON);
                    width = projectData.width;
                    height = projectData.height;
                    fontSize = projectData.fontSize;
                    
                    document.getElementById('width').value = width;
                    document.getElementById('height').value = height;
                    document.getElementById('fontSize').value = fontSize;
                    
                    calculateCharDimensions();
                    const canvas = document.getElementById('canvas');
                    canvas.innerHTML = '';
                    canvas.style.fontSize = fontSize + 'px';
                    
                    grid = projectData.grid.map(row => [...row]);
                    for (let y = 0; y < height; y++) {
                        const row = document.createElement('div');
                        row.className = 'row';
                        row.style.height = charHeight + 'px';

                        for (let x = 0; x < width; x++) {
                            const cell = document.createElement('span');
                            cell.className = 'cell';
                            cell.style.width = charWidth + 'px';
                            cell.style.height = charHeight + 'px';
                            cell.textContent = grid[y][x];
                            cell.dataset.x = x;
                            cell.dataset.y = y;

                            cell.addEventListener('mousedown', (e) => handleMouseDown(e, x, y));
                            cell.addEventListener('mouseenter', () => handleMouseEnter(x, y));

                            row.appendChild(cell);
                        }

                        canvas.appendChild(row);
                    }
                    
                    history = [grid.map(row => [...row])];
                    historyStep = 0;
                    updateUndoRedoButtons();
                    
                    alert('Project loaded: ' + projectName);
                } else {
                    alert('Project not found');
                }
            } catch (error) {
                console.error('Load error:', error);
                alert('Failed to load project');
            }
        }

        function loadLastProject() {
            try {
                const projects = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('ascii-project-')) {
                        const projectJSON = localStorage.getItem(key);
                        if (projectJSON) {
                            const data = JSON.parse(projectJSON);
                            projects.push(data);
                        }
                    }
                }
                
                if (projects.length > 0) {
                    projects.sort((a, b) => b.timestamp - a.timestamp);
                    loadProject(projects[0].name);
                } else {
                    alert('No saved projects found');
                }
            } catch (error) {
                console.error('Error loading last project:', error);
                alert('Failed to load last project');
            }
        }

        function deleteProject(projectName) {
            if (confirm('Delete project "' + projectName + '"?')) {
                try {
                    localStorage.removeItem('ascii-project-' + projectName);
                    loadProjectsList();
                } catch (error) {
                    console.error('Delete error:', error);
                }
            }
        }

        function loadProjectsList() {
            const listDiv = document.getElementById('savedProjectsList');
            listDiv.innerHTML = '';
            
            try {
                const projects = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('ascii-project-')) {
                        const projectJSON = localStorage.getItem(key);
                        if (projectJSON) {
                            const data = JSON.parse(projectJSON);
                            projects.push(data);
                        }
                    }
                }
                
                if (projects.length > 0) {
                    projects.sort((a, b) => b.timestamp - a.timestamp);
                    projects.forEach(project => {
                        const item = document.createElement('div');
                        item.className = 'saved-item';
                        
                     
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'saved-item-name';
                        nameSpan.textContent = project.name;
                        nameSpan.onclick = () => loadProject(project.name);
              
                           
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'saved-item-delete';
                        deleteBtn.textContent = '✕';
           
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            deleteProject(project.name);
                        };
   
                                             
                        item.appendChild(nameSpan);
                        item.appendChild(deleteBtn);
                        listDiv.appendChild(item);
                    });
                } else {
                    listDiv.innerHTML = '<div style="text-align:center;color:#8b949e;padding:10px;font-size:10px;">No saved projects</div>';
                }
            } catch (error) {
                console.error('Error loading projects list:', error);
                listDiv.innerHTML = '<div style="text-align:center;color:#8b949e;padding:10px;font-size:10px;">Error loading projects</div>';
            }
        }

        function downloadProject() {
            const projectName = document.getElementById('projectName').value.trim() ||
            'Untitled';
            
            const projectData = {
                name: projectName,
                width: width,
                height: height,
                fontSize: fontSize,
                grid: grid,
           
                timestamp: Date.now(),
                version: '1.0'
            };
            const dataStr = JSON.stringify(projectData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = projectName + '.json';
            a.click();
            
            URL.revokeObjectURL(url);
            alert('Project downloaded: ' + projectName + '.json');
        }

        function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    if (!projectData.grid || !projectData.width || !projectData.height) {
                        alert('Invalid project file');
                        return;
                    }
                    
                    width = projectData.width;
                    height = projectData.height;
                    fontSize = projectData.fontSize || 14;
                    
                    document.getElementById('width').value = width;
                    document.getElementById('height').value = height;
                    document.getElementById('fontSize').value = fontSize;
                    document.getElementById('projectName').value = projectData.name || 'Imported';
                    
                    calculateCharDimensions();
                    const canvas = document.getElementById('canvas');
                    canvas.innerHTML = '';
                    canvas.style.fontSize = fontSize + 'px';
                    grid = projectData.grid.map(row => [...row]);
                    
                    for (let y = 0; y < height; y++) {
                        const row = document.createElement('div');
                        row.className = 'row';
                        row.style.height = charHeight + 'px';

                        for (let x = 0; x < width; x++) {
                            const cell = document.createElement('span');
                            cell.className = 'cell';
                            cell.style.width = charWidth + 'px';
                            cell.style.height = charHeight + 'px';
                            cell.textContent = grid[y][x];
                            cell.dataset.x = x;
                            cell.dataset.y = y;

                            cell.addEventListener('mousedown', (e) => handleMouseDown(e, x, y));
                            cell.addEventListener('mouseenter', () => handleMouseEnter(x, y));

                            row.appendChild(cell);
                        }

                        canvas.appendChild(row);
                    }
                    
                    history = [grid.map(row => [...row])];
                    historyStep = 0;
                    updateUndoRedoButtons();
                    
                    alert('Project imported successfully!');
                } catch (error) {
                    console.error('Import error:', error);
                    alert('Failed to import project. Make sure it\'s a valid JSON file.');
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
           
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redo();
                } else if (e.key === 's') {
                    e.preventDefault();
 
                    saveProject();
                }
            }
        });
        initKeyboard();
        initCanvas();
        loadProjectsList();
    </script>
</body>
</html>
