<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Painting Tool</title>
    <style>
        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            /* Allow vertical scroll for small screens/collapsed panel */
            overflow-x: hidden; 
            overflow-y: auto;
        }

        /* Canvas Container */
        #canvasContainer {
            position: relative; 
            width: 100%;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            /* Default padding for open panel on mobile */
            padding-bottom: 250px; 
        }
        
        /* Canvas */
        #canvas {
            display: inline-block;
            background: #0d1117;
            border: 1px solid #30363d;
            padding: 10px;
            line-height: 1;
            cursor: crosshair;
            user-select: none;
            position: relative;
            white-space: pre; 
            max-width: 100%; 
            overflow: auto; 
        }

        #canvas.select-mode {
            cursor: default;
        }

        #canvas.eraser-mode {
            cursor: pointer;
        }

        .row {
            white-space: pre;
            display: flex; 
        }

        .cell {
            display: inline-block;
            text-align: center;
        }

        .cell:hover {
            background: #1f6feb;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #58a6ff;
            background: rgba(88, 166, 255, 0.1);
            pointer-events: none;
        }

        /* Control Panel Container (Mobile Default: Full-Width Bottom) */
        .panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #161b22;
            border-top: 1px solid #30363d;
            border-radius: 0; 
            width: 100%; 
            max-width: 100%;
            z-index: 1000;
            transition: all 0.3s ease-in-out; /* Added transition for smooth change to tiny button */
        }

        /* Panel Header (Mobile Default: Full-Width Collapse Button) */
        .panel-header {
            padding: 10px; 
            border-top: none; 
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            font-size: 14px; 
            transition: all 0.3s;
        }

        .panel-header:hover {
            background: #1c2128;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .current-char {
            display: inline-block;
            background: #0d1117;
            border: 1px solid #30363d;
            padding: 4px 8px;
            min-width: 30px;
            text-align: center;
        }

        .toggle-icon {
            font-size: 16px; 
            transition: transform 0.2s;
        }

        .toggle-icon.collapsed {
            transform: rotate(0deg); /* Icon points up when panel is open (mobile default) */
        }
        
        /* Icon points down when panel is collapsed (full width mobile) */
        .panel-content.collapsed + .panel-header .toggle-icon {
            transform: rotate(180deg); 
        }

        /* Panel Content */
        .panel-content {
            padding: 10px;
            max-height: 80vh; 
            overflow-y: auto;
            border-bottom: 1px solid #30363d;
        }

        .panel-content.collapsed {
            display: none;
        }

        /* --- Controls Styling (Rest remains unchanged) --- */
        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 11px;
            margin-bottom: 5px;
            color: #8b949e;
            text-transform: uppercase;
        }

        .size-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .size-inputs input {
            width: 70px; 
            font-size: 14px;
            padding: 8px 10px;
        }

        input, button {
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 8px 12px; 
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
        }

        button {
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #21262d;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: 6px; 
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            min-width: 60px;
        }
        
        .tool-mode {
            display: flex;
            gap: 6px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .tool-btn {
            flex: 1;
            padding: 8px;
            font-size: 12px;
            min-width: 60px;
        }

        .tool-btn.active {
            background: #1f6feb;
            border-color: #1f6feb;
        }

        .keyboard {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .kbd-row {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .key {
            background: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 6px 4px; 
            min-width: 28px; 
            text-align: center;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-radius: 3px;
            transition: all 0.1s;
        }

        .key:hover {
            background: #21262d;
            border-color: #58a6ff;
        }

        .key.active {
            background: #1f6feb;
            border-color: #1f6feb;
        }
        
        #customCharInput {
            width: 100%;
            padding: 8px;
            font-size: 14px;
        }

        #savedProjectsList {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #30363d;
            border-radius: 3px;
            padding: 5px;
            background: #0d1117;
            margin-top: 5px;
        }

        .saved-item {
            padding: 8px;
            cursor: pointer;
            border-radius: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
            font-size: 12px;
        }

        .saved-item:hover {
            background: #21262d;
        }

        .saved-item-delete {
            color: #f85149;
            font-size: 10px;
            padding: 4px 8px;
        }
        /* --- End Controls Styling --- */

        /* Media Queries for Desktop/Tablet Layout (>= 768px) */
        @media (min-width: 768px) {
            #canvasContainer {
                position: absolute;
                min-height: 100vh;
                padding-bottom: 20px; 
                overflow: hidden;
            }

            .panel {
                position: fixed;
                bottom: 20px;
                right: 20px;
                left: auto;
                width: 320px;
                border: 1px solid #30363d;
                border-radius: 6px;
                border-top: none;
            }
            
            .panel-header {
                padding: 8px 10px;
                border-top: 1px solid #30363d;
                font-size: 12px;
            }
            
            .toggle-icon.collapsed {
                transform: rotate(180deg); 
            }
            
            .panel-content.collapsed + .panel-header .toggle-icon {
                transform: rotate(0deg);
            }

            .panel-content.collapsed {
                display: none;
            }
            
            .panel-content {
                border-bottom: 1px solid #30363d;
            }
        }
        
        /* * MOBILE-ONLY STYLES (<= 767px) for TINY COLLAPSED BUTTON 
         */
        @media (max-width: 767px) {
            
            /* Override Canvas Container Padding when panel is tiny */
            #canvasContainer {
                padding-bottom: 20px; /* Reset padding to standard bottom margin */
            }

            /* * Styles for the header when the panel content is collapsed 
             * This creates the "really, really, really, really tiny button" 
             */
            .panel-content.collapsed + .panel-header {
                /* Positioning for tiny button */
                position: fixed; 
                bottom: 15px;    /* Small offset from bottom */
                right: 15px;     /* Small offset from right */
                left: auto;      /* Ignore left edge */
                
                /* Size - Very tiny as requested */
                width: 30px;     
                height: 30px;    
                min-width: 30px;
                
                /* Visuals */
                padding: 0;      
                border-radius: 50%; 
                justify-content: center; 
                align-items: center;
                overflow: hidden; 
                z-index: 1001; 
                border: 2px solid #58a6ff; 
                background: #1f6feb; 
                
                /* Ensure panel container doesn't override width */
                transform: translateX(0);
                
                /* Remove hover state background color change for better UX */
                background: #1f6feb; 
            }
            
            /* Remove hover effect from the tiny button */
            .panel-content.collapsed + .panel-header:hover {
                 background: #1f6feb;
            }

            /* Hide the title and character preview */
            .panel-content.collapsed + .panel-header .panel-title {
                display: none;
            }

            /* Adjust the icon for the tiny button */
            .panel-content.collapsed + .panel-header .toggle-icon {
                display: block;
                font-size: 18px; /* Slightly larger icon for better visibility on tiny target */
                color: #c9d1d9;
                /* Icon points down when collapsed/tiny */
                transform: rotate(180deg); 
            }
            
            /* Ensure the full .panel container is invisible when tiny/collapsed */
            .panel-content.collapsed {
                /* Only the header is visible, so the container is effectively the header */
                width: 30px;
            }

            /* When open, the panel should reset to full width at the bottom */
            .panel:not(.panel-content.collapsed ~ .panel-header) {
                width: 100%;
                left: 0;
                right: 0;
                bottom: 0;
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <div id="canvasContainer">
        <div id="canvas"></div>
    </div>

    <div class="panel">
        <div class="panel-content" id="panelContent">
            <div class="tool-mode">
                <button class="tool-btn active" onclick="setTool('draw')" id="drawBtn">DRAW</button>
                <button class="tool-btn" onclick="setTool('eraser')" id="eraserBtn">ERASE</button>
                <button class="tool-btn" onclick="setTool('fill')" id="fillBtn">FILL</button>
                <button class="tool-btn" onclick="setTool('select')" id="selectBtn">SELECT</button>
            </div>

            <div class="control-group">
                <label>Canvas Size</label>
                <div class="size-inputs">
                    <input type="number" id="width" value="120" min="10" max="200">
                    <span>×</span>
                    <input type="number" id="height" value="20" min="10" max="80">
                    <button onclick="resizeCanvas()">Apply</button>
                </div>
            </div>

            <div class="control-group">
                <label>Font Size / Cell Size</label>
                <div class="size-inputs">
                    <input type="number" id="fontSize" value="14" min="6" max="40" step="1">
                    <span>px</span>
                    <button onclick="updateFontSize()">Apply</button>
                </div>
            </div>

            <div class="control-group">
                <label>Actions</label>
                <div class="button-group">
                    <button onclick="undo()" id="undoBtn" disabled>Undo</button>
                    <button onclick="redo()" id="redoBtn" disabled>Redo</button>
                    <button onclick="clearCanvas()">Clear</button>
                    <button onclick="exportText()">Copy</button>
                    <button onclick="exportPNG()">PNG</button>
                </div>
            </div>

            <div class="control-group">
                <label>Save/Load Project (.json)</label>
                <input type="text" id="projectName" placeholder="Project name...">
                <div class="button-group">
                    <button onclick="saveProject()">Save</button>
                    <button onclick="loadLastProject()">Load Last</button>
                </div>
                <div class="button-group" style="margin-top: 4px;">
                    <button onclick="downloadProject()">Download</button>
                    <button onclick="document.getElementById('fileInput').click()">Import</button>
                </div>
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importProject(event)">
                <div id="savedProjectsList" style="margin-top: 5px;"></div>
            </div>

            <div class="control-group" id="selectionTools" style="display: none;">
                <label>Selection</label>
                <div class="button-group">
                    <button onclick="duplicateSelection()">Duplicate</button>
                    <button onclick="clearSelection()">Delete</button>
                    <button onclick="cancelSelection()">Cancel</button>
                </div>
            </div>

            <div class="control-group">
                <label>Custom Character</label>
                <input type="text" id="customCharInput" maxlength="1" placeholder="Enter any character">
            </div>

            <div class="control-group">
                <label>Characters</label>
                <div class="keyboard" id="keyboard"></div>
            </div>
        </div>

        <div class="panel-header" onclick="togglePanel()">
            <div class="panel-title">
                <span>TOOLS</span>
                <span class="current-char" id="charPreview">#</span>
            </div>
            <span class="toggle-icon" id="toggleIcon">▲</span> 
        </div>
    </div>

    <script>
        // --- Core Variables & Constants ---
        let width = 120;
        let height = 20;
        let fontSize = 14;
        // Use fixed aspect ratios for cross-device consistency
        const CHAR_WIDTH_RATIO = 0.6; 
        const CHAR_HEIGHT_RATIO = 1.15;
        let charWidth = 0;
        let charHeight = 0;
        let currentChar = '#';
        let currentTool = 'draw';
        let isDrawing = false;
        let grid = [];

        // Selection variables
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let selectionBox = null;
        let selectedData = null;
        let isDraggingSelection = false;
        let dragOffset = { x: 0, y: 0 };
        let dragStartPos = null;
        let gridBeforeDrag = null;

        // History variables
        let history = [];
        let historyStep = -1;
        const MAX_HISTORY = 50;
        
        // Character sets
        const blocks = ['█', '▓', '▒', '░', '▀', '▄', '▌', '▐', '■', '□', '▪', '▫', '◘', '◙'];
        const lines = ['─', '│', '┌', '┐', '└', '┘', '├', '┤', '┬', '┴', '┼', '═', '║', '╔', '╗', '╚', '╝', '╠', '╣', '╦', '╩', '╬'];
        const basic = ['/', '\\', '|', '-', '+', '*', '#', '@', '$', '%', '&', '!', '?', '~', '^', '=', '_', '<', '>', '.', ',', ':', ';'];
        const brackets = ['(', ')', '[', ']', '{', '}'];
        const quotes = ['"', "'", '`'];
        const math = ['÷', '×', '±', '≈', '≠', '≤', '≥', '∞', '∑', '√', '∫'];
        const arrows = ['←', '→', '↑', '↓', '↔', '↕', '⇐', '⇒'];
        const shapes = ['○', '●', '◯', '☐', '☑', '☒', '♠', '♣', '♥', '♦', '★', '☆'];
        const greek = ['α', 'β', 'γ', 'δ', 'ε', 'π', 'σ', 'ω', 'Σ', 'Π', 'Ω'];
        const misc = ['©', '®', '™', '§', '¶', '†', '°', '¢', '£', '¥', '€'];
        const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const letters = 'QWERTYUIOPASDFGHJKLZXCVBNM'.split('');
        const lowercase = 'qwertyuiopasdfghjklzxcvbnm'.split('');

        // --- Cross-Device Consistency & Scaling ---

        /**
         * Calculates cell dimensions using a fixed ratio to the font size.
         */
        function calculateCharDimensions() {
            // Use fixed, consistent ratios and round to nearest integer to prevent
            // sub-pixel rendering issues (gaps/lines).
            charWidth = Math.round(fontSize * CHAR_WIDTH_RATIO);
            charHeight = Math.round(fontSize * CHAR_HEIGHT_RATIO); 
        }

        /**
         * Applies the calculated font size and dimensions to the DOM elements.
         */
        function applyCanvasStyles() {
            calculateCharDimensions();
            const canvas = document.getElementById('canvas');
            canvas.style.fontSize = fontSize + 'px';
            
            // Set styles for all rows and cells
            const rows = document.querySelectorAll('#canvas .row');
            const cells = document.querySelectorAll('#canvas .cell');
            
            rows.forEach(row => {
                row.style.height = charHeight + 'px';
            });
            
            cells.forEach(cell => {
                cell.style.width = charWidth + 'px';
                cell.style.height = charHeight + 'px';
            });
            
            // Update the character preview size
            document.getElementById('charPreview').style.fontSize = fontSize + 'px';
            
            // Update selection box if present
            if (selectionBox) updateSelectionBox();
        }

        // --- UI & Controls ---

        function initKeyboard() {
            const kbd = document.getElementById('keyboard');
            kbd.innerHTML = ''; // Clear existing
            addKeyRow(kbd, blocks);
            addKeyRow(kbd, lines.slice(0, 15));
            addKeyRow(kbd, basic);
            addKeyRow(kbd, [...brackets, ...quotes]);
            addKeyRow(kbd, math);
            addKeyRow(kbd, arrows);
            addKeyRow(kbd, shapes);
            addKeyRow(kbd, greek);
            addKeyRow(kbd, misc);
            addKeyRow(kbd, numbers);
            addKeyRow(kbd, letters.slice(0, 13));
            addKeyRow(kbd, letters.slice(13));
            addKeyRow(kbd, lowercase.slice(0, 13));
            addKeyRow(kbd, lowercase.slice(13));
            addKeyRow(kbd, [' ']);
            selectChar(currentChar); // Re-select to highlight active key
        }

        function addKeyRow(parent, keys) {
            const row = document.createElement('div');
            row.className = 'kbd-row';
            keys.forEach(key => {
                const btn = document.createElement('div');
                btn.className = 'key';
                btn.textContent = key === ' ' ? '⎵' : key;
                btn.onclick = () => selectChar(key);
                if (key === currentChar) btn.classList.add('active');
                row.appendChild(btn);
            });
            parent.appendChild(row);
        }

        document.getElementById('customCharInput').addEventListener('input', (e) => {
            const char = e.target.value;
            if (char) {
                selectChar(char);
                e.target.value = '';
            }
        });
        
        function selectChar(char) {
            currentChar = char;
            document.querySelectorAll('.key').forEach(b => b.classList.remove('active'));
            
            // Find and activate the key for the selected character
            document.querySelectorAll('.key').forEach(btn => {
                const charContent = btn.textContent === '⎵' ? ' ' : btn.textContent;
                if (charContent === char) {
                    btn.classList.add('active');
                }
            });
            
            const preview = document.getElementById('charPreview');
            preview.textContent = char === ' ' ? '⎵' : char;
            preview.style.fontSize = fontSize + 'px';
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(tool + 'Btn').classList.add('active');

            const canvas = document.getElementById('canvas');
            canvas.classList.remove('select-mode', 'eraser-mode');
            if (tool === 'select') {
                canvas.classList.add('select-mode');
            } else if (tool === 'eraser') {
                canvas.classList.add('eraser-mode');
                cancelSelection();
            } else {
                cancelSelection();
            }
        }

        function togglePanel() {
            const content = document.getElementById('panelContent');
            const icon = document.getElementById('toggleIcon');
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
            
            // Adjust canvas padding for mobile only when opening/closing
            const isMobile = window.matchMedia('(max-width: 767px)').matches;
            const container = document.getElementById('canvasContainer');
            if (isMobile) {
                // If opening (content not collapsed), set large padding
                if (!content.classList.contains('collapsed')) {
                    container.style.paddingBottom = '250px';
                } else {
                    // If collapsing (content collapsed), set small padding
                    container.style.paddingBottom = '20px';
                }
            }
        }

        function updateFontSize() {
            fontSize = parseInt(document.getElementById('fontSize').value);
            // Re-calculate and apply styles
            applyCanvasStyles();
        }

        // --- History Management ---

        function saveState() {
            history = history.slice(0, historyStep + 1);
            const gridCopy = grid.map(row => [...row]);
            history.push(gridCopy);

            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyStep++;
            }

            updateUndoRedoButtons();
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                restoreState(history[historyStep]);
                updateUndoRedoButtons();
                cancelSelection();
            }
        }

        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                restoreState(history[historyStep]);
                updateUndoRedoButtons();
                cancelSelection();
            }
        }

        function restoreState(state) {
            grid = state.map(row => [...row]);
            renderGrid();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyStep <= 0;
            document.getElementById('redoBtn').disabled = historyStep >= history.length - 1;
        }

        // --- Canvas Initialization & Rendering ---

        function initCanvas() {
            width = parseInt(document.getElementById('width').value);
            height = parseInt(document.getElementById('height').value);
            
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '';
            grid = [];
            
            // Re-calculate dimensions based on current font size
            applyCanvasStyles(); 

            for (let y = 0; y < height; y++) {
                const row = document.createElement('div');
                row.className = 'row';
                row.style.height = charHeight + 'px';
                grid[y] = [];
                for (let x = 0; x < width; x++) {
                    const cell = document.createElement('span');
                    cell.className = 'cell';
                    cell.style.width = charWidth + 'px';
                    cell.style.height = charHeight + 'px';
                    cell.textContent = ' ';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    // Use 'pointerdown' for more reliable mobile touch events
                    cell.addEventListener('mousedown', (e) => handleMouseDown(e, x, y));
                    cell.addEventListener('touchstart', (e) => handleMouseDown(e, x, y), { passive: true });
                    
                    cell.addEventListener('mouseenter', () => handleMouseEnter(x, y));
                    // Mobile equivalent of mouseenter for drawing/erasing
                    cell.addEventListener('touchmove', (e) => handleTouchMove(e, x, y), { passive: false });

                    row.appendChild(cell);
                    grid[y][x] = ' ';
                }

                canvas.appendChild(row);
            }

            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleMouseUp); // Use touchend for mobile

            saveState();
        }

        // --- Event Handlers (Updated for Touch) ---

        function getEventCoords(e) {
            // Use e.changedTouches[0] for touch events, or e for mouse events
            const clientX = e.clientX !== undefined ? e.clientX : e.changedTouches[0]?.clientX;
            const clientY = e.clientY !== undefined ? e.clientY : e.changedTouches[0]?.clientY;
            
            if (clientX === undefined || clientY === undefined) return null;

            const canvasRect = document.getElementById('canvas').getBoundingClientRect();
            // Calculate coordinates relative to the canvas content area
            const canvasX = clientX - canvasRect.left;
            const canvasY = clientY - canvasRect.top;
            
            // Adjust for canvas scroll (important if content overflows on mobile)
            const scrollX = document.getElementById('canvas').scrollLeft;
            const scrollY = document.getElementById('canvas').scrollTop;
            
            // Calculate grid index: (relative pos + scroll) / cell size
            const x = Math.floor((canvasX + scrollX) / charWidth);
            const y = Math.floor((canvasY + scrollY) / charHeight);
            
            // Clamp to grid boundaries
            return {
                x: Math.max(0, Math.min(width - 1, x)),
                y: Math.max(0, Math.min(height - 1, y))
            };
        }

        function handleTouchMove(e) {
            // Prevent scrolling while drawing/selecting
            if (isDrawing || isSelecting || isDraggingSelection) {
                e.preventDefault(); 
            }
            
            const coords = getEventCoords(e);
            if (!coords) return;
            handleMouseEnter(coords.x, coords.y);
        }
        
        function handleMouseDown(e, x, y) {
            // Prevent default browser behavior (e.g., selection) for mouse events
            if (e.type === 'mousedown') e.preventDefault();
            
            // Use the passed x, y for the initial click/touch point
            const startX = x;
            const startY = y;

            if (currentTool === 'draw') {
                isDrawing = true;
                drawCell(startX, startY);
            } else if (currentTool === 'eraser') {
                isDrawing = true;
                eraseCell(startX, startY);
            } else if (currentTool === 'fill') {
                floodFill(startX, startY);
            } else if (currentTool === 'select') {
                if (selectionBox && isInsideSelection(startX, startY)) {
                    // Start Drag
                    isDraggingSelection = true;
                    dragStartPos = { x: startX, y: startY };
                    
                    const minX = Math.min(selectionStart.x, selectionEnd.x);
                    const minY = Math.min(selectionStart.y, selectionEnd.y);
                    dragOffset = {
                        x: startX - minX,
                        y: startY - minY
                    };
                    
                    // Store grid state *without* the selected content for clean drag
                    gridBeforeDrag = grid.map(row => [...row]);
                    const maxX = Math.max(selectionStart.x, selectionEnd.x);
                    const maxY = Math.max(selectionStart.y, selectionEnd.y);
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            gridBeforeDrag[y][x] = ' '; // Clear selection area in the temp grid
                        }
                    }
                    
                } else {
                    // Start Selection
                    isSelecting = true;
                    selectionStart = { x: startX, y: startY };
                    selectionEnd = { x: startX, y: startY };
                    createSelectionBox();
                }
            }
        }

        function handleMouseEnter(x, y) {
            if (isDrawing && currentTool === 'draw') {
                drawCell(x, y);
            } else if (isDrawing && currentTool === 'eraser') {
                eraseCell(x, y);
            } else if (isSelecting) {
                selectionEnd = { x, y };
                updateSelectionBox();
            } else if (isDraggingSelection) {
                moveSelection(x, y);
            }
        }

        function handleMouseUp() {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            } else if (isSelecting) {
                isSelecting = false;
                finalizeSelection();
            } else if (isDraggingSelection) {
                isDraggingSelection = false;
                dragStartPos = null;
                gridBeforeDrag = null;
                saveState();
            }
        }

        // --- Selection & Drag Logic ---

        function isInsideSelection(x, y) {
            if (!selectionStart || !selectionEnd) return false;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            return x >= minX && x <= maxX && y >= minY && y <= maxY;
        }

        function createSelectionBox() {
            if (selectionBox) selectionBox.remove();
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            document.getElementById('canvas').appendChild(selectionBox);
            updateSelectionBox();
        }

        function updateSelectionBox() {
            if (!selectionBox || !selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            
            // Crucial: Use charWidth and charHeight for pixel values for consistency
            selectionBox.style.left = (minX * charWidth) + 'px';
            selectionBox.style.top = (minY * charHeight) + 'px';
            selectionBox.style.width = ((maxX - minX + 1) * charWidth) + 'px';
            selectionBox.style.height = ((maxY - minY + 1) * charHeight) + 'px';
        }

        function finalizeSelection() {
            if (!selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            
            // Only finalize if a selection area exists (i.e., not a single cell click)
            if (minX !== maxX || minY !== maxY) {
                selectedData = [];
                for (let y = minY; y <= maxY; y++) {
                    const row = [];
                    for (let x = minX; x <= maxX; x++) {
                        row.push(grid[y][x]);
                    }
                    selectedData.push(row);
                }
                document.getElementById('selectionTools').style.display = 'block';
            } else {
                 cancelSelection(); // Cancel if it's just a click
            }
        }

        function moveSelection(x, y) {
            if (!selectedData || !dragStartPos || !gridBeforeDrag) return;
            
            // Calculate new top-left corner index
            const newX = x - dragOffset.x;
            const newY = y - dragOffset.y;

            const w = selectedData[0].length;
            const h = selectedData.length;
            
            // Clamp new position to grid boundaries
            const clampedX = Math.max(0, Math.min(width - w, newX));
            const clampedY = Math.max(0, Math.min(height - h, newY));
            
            // Restore grid to its pre-drag state
            grid = gridBeforeDrag.map(row => [...row]);

            // Place selected data at the clamped new position
            for (let sy = 0; sy < h; sy++) {
                for (let sx = 0; sx < w; sx++) {
                    const targetY = clampedY + sy;
                    const targetX = clampedX + sx;
                    const char = selectedData[sy][sx];
                    if (char !== ' ' && targetY >= 0 && targetY < height && targetX >= 0 && targetX < width) {
                        grid[targetY][targetX] = char;
                    }
                }
            }

            // Update selection box boundaries to the new position
            selectionStart = { x: clampedX, y: clampedY };
            selectionEnd = { x: clampedX + w - 1, y: clampedY + h - 1 };

            renderGrid();
            updateSelectionBox();
        }

        function duplicateSelection() {
            if (!selectedData || !selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const w = selectedData[0].length;
            const h = selectedData.length;

            // Calculate new position (two cells to the right)
            const newX = Math.min(minX + w + 2, width - w);
            const newY = minY;
            
            if (newX === minX) {
                alert("Cannot duplicate: Not enough space to the right.");
                return;
            }

            for (let sy = 0; sy < h; sy++) {
                for (let sx = 0; sx < w; sx++) {
                    const targetY = newY + sy;
                    const targetX = newX + sx;
                    const char = selectedData[sy][sx];
                    if (char !== ' ' && targetY >= 0 && targetY < height && targetX >= 0 && targetX < width) {
                        grid[targetY][targetX] = char;
                    }
                }
            }

            renderGrid();
            saveState();
        }

        function clearSelection() {
            if (!selectionStart || !selectionEnd) return;
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x < maxX + 1; x++) {
                    grid[y][x] = ' ';
                }
            }

            renderGrid();
            saveState();
            cancelSelection();
        }

        function cancelSelection() {
            if (selectionBox) {
                selectionBox.remove();
                selectionBox = null;
            }
            selectionStart = null;
            selectionEnd = null;
            selectedData = null;
            dragStartPos = null;
            gridBeforeDrag = null;
            document.getElementById('selectionTools').style.display = 'none';
        }

        // --- Drawing and Canvas Operations ---

        function drawCell(x, y) {
            const cell = document.querySelector('[data-x="' + x + '"][data-y="' + y + '"]');
            if (cell) {
                cell.textContent = currentChar;
                grid[y][x] = currentChar;
            }
        }

        function eraseCell(x, y) {
            const cell = document.querySelector('[data-x="' + x + '"][data-y="' + y + '"]');
            if (cell) {
                cell.textContent = ' ';
                grid[y][x] = ' ';
            }
        }

        function renderGrid() {
            // Rerenders the DOM content to match the grid array
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = document.querySelector('[data-x="' + x + '"][data-y="' + y + '"]');
                    if (cell) {
                        cell.textContent = grid[y][x];
                    }
                }
            }
        }

        function floodFill(startX, startY) {
            const targetChar = grid[startY][startX];
            if (targetChar === currentChar) return;
            if (startX < 0 || startX >= width || startY < 0 || startY >= height) return;

            const stack = [[startX, startY]];
            while (stack.length > 0) {
                const pos = stack.pop();
                const x = pos[0];
                const y = pos[1];

                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                if (grid[y][x] !== targetChar) continue;
                
                grid[y][x] = currentChar;
                
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }

            renderGrid();
            saveState();
        }

        function clearCanvas() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    grid[y][x] = ' ';
                }
            }
            renderGrid();
            saveState();
            cancelSelection();
        }

        function resizeCanvas() {
            // Note: initCanvas handles updating width/height/DOM/styles
            initCanvas(); 
        }

        // --- Export/Import ---

        function exportText() {
            const text = grid.map(row => row.join('')).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard');
            }).catch(err => {
                 alert('Failed to copy text: ' + err);
            });
        }

        function exportPNG() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = width * charWidth;
            canvas.height = height * charHeight;

            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Important: Use 'px' for font size and ensure monospace font is used
            ctx.font = `${fontSize}px 'Courier New', monospace`; 
            ctx.fillStyle = '#c9d1d9';
            ctx.textBaseline = 'top'; // Align text correctly to the top of the cell
            
            // Adjust X position to account for the font's internal character padding
            // A small offset often centers it better within the calculated charWidth
            const xOffset = (charWidth - ctx.measureText(currentChar).width) / 2 || 0; 
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const char = grid[y][x];
                    if (char !== ' ') {
                        // Use fixed charWidth/charHeight for positioning
                        ctx.fillText(char, x * charWidth + xOffset, y * charHeight); 
                    }
                }
            }

            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ascii-art.png';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        // --- Save/Load Project (LocalStorage/File) ---
        
        // Project versioning for future compatibility checks
        const PROJECT_VERSION = '2.0'; 
        const LOCAL_STORAGE_PREFIX = 'ascii-project-';

        function createProjectData(projectName) {
            return {
                name: projectName,
                width: width,
                height: height,
                fontSize: fontSize, // Save font size for cross-device consistency
                grid: grid,
                timestamp: Date.now(),
                version: PROJECT_VERSION
            };
        }

        function saveProject() {
            const projectName = document.getElementById('projectName').value.trim() || 'Untitled';
            const projectData = createProjectData(projectName);
            
            try {
                localStorage.setItem(LOCAL_STORAGE_PREFIX + projectName, JSON.stringify(projectData));
                alert('Project saved: ' + projectName);
                loadProjectsList();
            } catch (error) {
                console.error('Save error:', error);
                alert('Failed to save project. Storage capacity may be full.');
            }
        }

        function loadProject(projectName) {
            try {
                const projectJSON = localStorage.getItem(LOCAL_STORAGE_PREFIX + projectName);
                if (projectJSON) {
                    const projectData = JSON.parse(projectJSON);
                    applyProjectData(projectData);
                    document.getElementById('projectName').value = projectName;
                    alert('Project loaded: ' + projectName);
                } else {
                    alert('Project not found');
                }
            } catch (error) {
                console.error('Load error:', error);
                alert('Failed to load project');
            }
        }

        function applyProjectData(projectData) {
            // Apply all relevant data, including the crucial fontSize
            width = projectData.width;
            height = projectData.height;
            fontSize = projectData.fontSize || 14; 
            
            // Update inputs
            document.getElementById('width').value = width;
            document.getElementById('height').value = height;
            document.getElementById('fontSize').value = fontSize;
            
            // Re-initialize canvas with new dimensions and font size
            grid = projectData.grid.map(row => [...row]);
            initCanvasWithGrid(); 
            
            // Update history
            history = [grid.map(row => [...row])];
            historyStep = 0;
            updateUndoRedoButtons();
            cancelSelection();
            selectChar(currentChar); // Update char preview size
        }
        
        function initCanvasWithGrid() {
            // Helper function to re-draw the canvas with existing grid data
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '';
            
            applyCanvasStyles(); 

            for (let y = 0; y < height; y++) {
                const row = document.createElement('div');
                row.className = 'row';
                row.style.height = charHeight + 'px';

                for (let x = 0; x < width; x++) {
                    const cell = document.createElement('span');
                    cell.className = 'cell';
                    cell.style.width = charWidth + 'px';
                    cell.style.height = charHeight + 'px';
                    cell.textContent = grid[y][x] || ' '; // Handle potential missing data
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    cell.addEventListener('mousedown', (e) => handleMouseDown(e, x, y));
                    cell.addEventListener('touchstart', (e) => handleMouseDown(e, x, y), { passive: true });
                    
                    cell.addEventListener('mouseenter', () => handleMouseEnter(x, y));
                    cell.addEventListener('touchmove', (e) => handleTouchMove(e, x, y), { passive: false });

                    row.appendChild(cell);
                }

                canvas.appendChild(row);
            }
            
            // Ensure proper canvas padding is restored/set after loading if it's open
             const isMobile = window.matchMedia('(max-width: 767px)').matches;
             const content = document.getElementById('panelContent');
             if (isMobile && !content.classList.contains('collapsed')) {
                 document.getElementById('canvasContainer').style.paddingBottom = '250px';
             } else if (isMobile && content.classList.contains('collapsed')) {
                 document.getElementById('canvasContainer').style.paddingBottom = '20px';
             }
        }


        function loadLastProject() {
            try {
                const projects = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(LOCAL_STORAGE_PREFIX)) {
                        const projectJSON = localStorage.getItem(key);
                        if (projectJSON) {
                            const data = JSON.parse(projectJSON);
                            projects.push(data);
                        }
                    }
                }
                
                if (projects.length > 0) {
                    projects.sort((a, b) => b.timestamp - a.timestamp);
                    loadProject(projects[0].name);
                } else {
                    alert('No saved projects found');
                }
            } catch (error) {
                console.error('Error loading last project:', error);
                alert('Failed to load last project');
            }
        }

        function deleteProject(projectName) {
            if (confirm('Delete project "' + projectName + '"?')) {
                try {
                    localStorage.removeItem(LOCAL_STORAGE_PREFIX + projectName);
                    loadProjectsList();
                } catch (error) {
                    console.error('Delete error:', error);
                }
            }
        }

        function loadProjectsList() {
            const listDiv = document.getElementById('savedProjectsList');
            listDiv.innerHTML = '';
            
            try {
                const projects = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(LOCAL_STORAGE_PREFIX)) {
                        const projectJSON = localStorage.getItem(key);
                        if (projectJSON) {
                            const data = JSON.parse(projectJSON);
                            projects.push(data);
                        }
                    }
                }
                
                if (projects.length > 0) {
                    projects.sort((a, b) => b.timestamp - a.timestamp);
                    projects.forEach(project => {
                        const item = document.createElement('div');
                        item.className = 'saved-item';
                        
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'saved-item-name';
                        nameSpan.textContent = project.name;
                        nameSpan.onclick = () => loadProject(project.name);
                           
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'saved-item-delete';
                        deleteBtn.textContent = '✕';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            deleteProject(project.name);
                        };
                                             
                        item.appendChild(nameSpan);
                        item.appendChild(deleteBtn);
                        listDiv.appendChild(item);
                    });
                } else {
                    listDiv.innerHTML = '<div style="text-align:center;color:#8b949e;padding:10px;font-size:10px;">No saved projects</div>';
                }
            } catch (error) {
                console.error('Error loading projects list:', error);
                listDiv.innerHTML = '<div style="text-align:center;color:#8b949e;padding:10px;font-size:10px;">Error loading projects</div>';
            }
        }

        function downloadProject() {
            const projectName = document.getElementById('projectName').value.trim() || 'Untitled';
            const projectData = createProjectData(projectName);
            
            const dataStr = JSON.stringify(projectData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = projectName + '.json';
            a.click();
            
            URL.revokeObjectURL(url);
            alert('Project downloaded: ' + projectName + '.json');
        }

        function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    if (!projectData.grid || !projectData.width || !projectData.height) {
                        alert('Invalid project file: Missing core data.');
                        return;
                    }
                    
                    // Crucial Step: The system is cross-device compatible because 
                    // the font size is saved and restored from the file.
                    applyProjectData(projectData);
                    document.getElementById('projectName').value = projectData.name || 'Imported Project';
                    
                    alert('Project imported successfully! Canvas size: ' + projectData.width + 'x' + projectData.height + '. Font size: ' + projectData.fontSize + 'px');
                } catch (error) {
                    console.error('Import error:', error);
                    alert('Failed to import project. Make sure it\'s a valid JSON file.');
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        // --- Global Event Listeners (Keyboard Shortcuts) ---

        document.addEventListener('keydown', (e) => {
            // Only allow shortcuts if not typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; 
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redo();
                } else if (e.key === 's') {
                    e.preventDefault();
                    saveProject();
                }
            }
        });
        
        // --- Initialization on Load ---
        
        // Mobile-first: start with the panel collapsed for desktop, open for mobile
        const isMobile = window.matchMedia('(max-width: 767px)').matches;
        if (!isMobile) {
            // Desktop/Tablet initialization (Default collapsed)
            document.getElementById('panelContent').classList.add('collapsed');
            document.getElementById('toggleIcon').classList.add('collapsed');
        } else {
             // Mobile initialization (Default open)
            document.getElementById('canvasContainer').style.paddingBottom = '250px';
        }

        initKeyboard();
        initCanvas(); // Also calls applyCanvasStyles and saveState(initial)
        loadProjectsList();
    </script>
</body>
</html>
